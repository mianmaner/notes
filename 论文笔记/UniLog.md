### 背景

① 现有工作无法同时确定日志位置、生成日志消息和设置详细级别
② 现有工作需要大量计算成本和时间成本，非常需要一种端到端、轻量级且与代码相关的日志记录解决方案

### 框架

UniLog 建立在具有大型语言模型 Codex 的上下文学习范例之上

![image-20240712171329509](https://gitee.com/mianmann/drawing-bed-warehouse/raw/master/img/image-20240712171329509.png)

#### 提示策略

我们特别关注插入的目标行对日志记录任务的敏感性，并设计了一个行感知提示模板
![image-20240712171107556](https://gitee.com/mianmann/drawing-bed-warehouse/raw/master/img/image-20240712171107556.png)

这里使用基于 KNN 的采样方法选择了与查询片段最为相似的五个标记样本作为模板

#### 预热策略

预热策略和微调的区别：
<img src="https://gitee.com/mianmann/drawing-bed-warehouse/raw/master/img/image-20240712173246809.png" alt="image-20240712173246809" style="zoom:40%;" />

预热使用完整的提示作为输入，每个提示包含一条指令、几个演示示例和一个查询，而微调则仅使用查询进行训练

此外，预热只需要非常少量的训练数据，明显少于微调中使用的数据，这有助于降低过度拟合的风险。在我们的实现中，我们将所有预热样本的指令设置为同一目标（即日志语句生成），并将标记的代码片段设置为提示示例，以针对特定任务的方式提高 ICL 能力

### 总结

主要设计点还是 prompt 策略，在代码生成上，Warmup 的确比 Fine-tuning 更加有用。贡献点在于同时解决了同时确定日志位置、生成日志消息和设置详细级别的问题
