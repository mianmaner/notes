#### 绪论

**1. 数据结构的三要素**

逻辑结构：定义一种数据结构
数据的运算：实际需求
存储结构：计算机如何实现

**2. 数据类型和抽象数据类型**

数据类型：是一个值的集合和定义在此集合上的一组操作的总称

① 原子类型：其值不可再分的数据类型
② 结构类型：其值可以再分的数据类型

抽象数据类型（$ADT$）：$ADT=(D,S,P)$
($D$：数据对象、$S$：关系集、$P$：操作集)

**3. 算法**

定义：一个有穷的指令集，用于解决特定问题
特性：输入、输出、确定性、有穷性、有效性

**4. 时间复杂度、空间复杂度**

渐近记法：
① $O$：函数上界
② $o$：非最小上界
③ Ω：函数下界
④ ω：非最大下界
⑤ θ：最小上界

时间复杂度：$O(\log n)<O(n)<O(n\log n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$

空间复杂度：一般为 $O(n^k)$，k 为递归调用的深度

#### 线性表

**1. 结构**

顺序结构（顺序表）：顺序存储的方式实现，即数组
链式结构：链式存储的方式实现，即链表

**2. 特点**

① 线性表中的每个元素的数据类型必须相同，并且不可以被分解成更小的数据单元
② 单链表又称线性链表，在单链表上实施插入和删除操作不需移动节点，只需改变节点指针

#### 栈

**1. 栈的定义**

只能在一端操作（栈顶），后入先出

**2. 前缀表达式、中缀表达式、后缀表达式**

① 它们分别对应着用树存储表达式的三种遍历方式
② 中缀表达式是我们常用的表达式
③ 写出表达式的树的存储结构便可快速解题

后缀表达式求值：用栈实现

#### 队列

**1. 定义**

插入和删除在不同端进行，添加新元素的一端为队尾(rear)，删除元素的一端为队首(front)，先入先出

**2. 单调队列**

#### 串

**1. 结构**

顺序串：数组存储
链接串：链接存储

**2. 串的匹配**

Brute-Force 算法（蛮力算法）、KMP算法、BM 算法

**KMP 算法**

> 一个人能走的多远不在于他在顺境时能走的多快，而在于他在逆境时多久能找到曾经的自己

设主串长度 $n$，子串长度 $m$，则时间复杂度为 $O(m+n)$
$next$ 数组：$next[i]=j\rightarrow p[1:j]=p[i-j+1:i]$

**3. 串的统计**

Trie 树：高效的存储和查找字符串集合的数据结构

#### 并查集

**1. 主要用于两个操作**

① 将两个集合合并
② 询问两个元素是否在一个集合当中

**2. 原理**

每个集合用一棵树来表示，树根的编号就是整个集合的编号，每个节点存储它的父节点，p[x] 表示 x 的父节点

合并两个集合：一个集合的根节点作为另一个集合的子节点

**3. 并查集的优化**

查到根节点后直接将路径上所有点直接设置为根节点子节点

#### 矩阵

**1. 三对角矩阵**

特殊存储方式：(3n-2)个元素的一维数组

> 例：2 1 0 0
>        3 1 3 0
>        0 5 2 7
>        0 0 9 0
> 逐行映射：t=[2,1,3,1,3,5,2,7,9,0]
> 逐列映射：t=[2,3,1,1,5,3,2,9,7,0]
> 对角线映射：t=[3,5,9,2,1,2,0,1,3,7]

**2. 三角矩阵**

特殊存储方式：同三对角矩阵，但只有逐行映射和逐列映射

**3. 稀疏矩阵**

特殊存储方式：三元组 `(row,col,value)`

#### 散列

**1. 散列表**

在表项的存储位置和表项关键字之间确立一个确定的对应函数关系`Hash()`，使每个关键字值与唯一的一个存储位置对应

散列法分为：
① 拉链法：发生冲突依然存储在同一地址，用单链表维护
② 开放寻址法：一旦发生了冲突，就去寻找下一个空的散列地址

**2. 构造 Hash 函数**

① 直接定址法
② 数字分析法：取关键字不同位上的数
③ 平方取中法：取关键字平方后的中间几位为哈希地址
④ 折叠法：适用于关键字位数很多的情况
⑤ 除留余数法
⑥ 伪随机数法
⑦ 多项式法：针对字符串的哈希值

**3. 处理冲突**

① 线性探测法
② 平方探测法
③ 双散列法
④ 链表法

**4. 平均查找长度**

**5. 字符串哈希**

前缀哈希法

#### 树

**1. 二叉树**

分类：
① 满二叉树：所有节点的度数只能为 0 或 2
② 完全二叉树：从上到下、从左到右为满节点
③ 完美二叉树：高度为 $h$，节点数为 $(2^h-1)$

性质：
① 高度为 $h$ 的树最多有 $(2^h-1)$ 个节点，包含 $n$ 个节点的二叉树高度最小为 $log_2(n+1)$
② 从上到下逐行，每行从左到右依次编号，则编号为i的节点的左孩子编号为 2i+1，右孩子编号为 2i+2
③ 设二叉树中度为 i 的节点为 $n_i$ 个，则 $n_0=n_2+1$
④ 已知先序遍历和后序遍历时，无法得出二叉树，其余情况均可

**2. 优先队列**

(其实就是队列内部多了一个排序，一般用树实现，可以用来模拟堆)
优先队列建立在树形结构上，每个元素都有一个优先权值，不是按入队次序出队，而是按照优先级出队

**3. 堆**

分类：
① 最大堆：是一颗最大树，且是一棵完全二叉树
② 最小堆：是一颗最小树，且是一颗完全二叉树

**4. 霍夫曼树**

霍夫曼编码：（ $F(a)$ 是 $a$ 出现的次数）
<img src="https://s2.loli.net/2023/07/31/96T3jGEDenNkldy.png" alt="image-20230205214836881" style="zoom:50%;" />

霍夫曼树：使编码后长度最短的树，节点的权值是字符频率

构造：选择两个节点权值最小的树合并，权值相加得到的新权值作为根节点得到新树，重复上述过程

**二叉搜索树**

二叉搜索树（BST）：左节点小于根节点、右节点大于根节点。另外在二叉搜索树上不存在重复节点

平衡二叉树（AVL 树）：所有节点的平衡因子都不超过1的二叉搜索树

> 平衡因子：某个节点左子树的高度减去右子树的高度得到的差值

**B 树**：对于一个 m 阶的 B 树，特征如下
① 是一颗m叉搜索树，每个节点最多有 m-1 个元素，m 个子节点
② 根节点至少有 2个孩子
③ 除根节点外，内部节点至少有 [m/2]（向上取整）个孩子
④ 所有叶子节点位于同一层上

**红黑树**：一颗红黑树需满足以下条件
① 每个结点或是红色，或是黑色的
② 根结点是黑色的
③ 叶结点(虚构的外部结点，NULL结点)都是黑色的
④ 如果一个结点是红色的，则它的两个子结点都是黑色的
⑤ 对每个结点，从该结点到任一叶结点的简单路径上，所含黑结点的数量相同

> 指针的颜色：黑指针指向的孩子节点是黑的，红指针指向的孩子节点是红的
> 性质：设从根到外部节点的路径长度是该路径中边(指针)的数量，若P、Q是红黑树中两条从根至外部节点的路径，那么 $length(P)≤2length(Q)$

#### 图

**1. 概念**

① 简单路径：顶点不重复的路径
② 连通图：任意两个节点都是连通的
③ 连通分量：无向图中的极大连通子图
④ 强连通图：对于有向图，任意两个节点都是双向连通的
⑤ 强连通分量：有向图的极大强连通子图
⑥ 生成树：包含图的所有节点且是其子图的树
⑦ 关节点：删除该节点会导致原图的连通分量变多
⑧ 双连通图：没有关节点的图
⑨ 双连通分量：极大的双连通子图

**2. 表示方式**

① 邻接矩阵
② 关联矩阵：顶点与边的关系
③ 邻接链表：多少个节点就有多少个表头（结点存储：关联节点、与关联节点对应的路径长、节点关键值等）
④ 十字链表

**3. 最小生成树**

最小指的是各边总权重达到最小

① Prim 算法：从任一顶点开始，每次添加与生成树距离最小的点
② Kruskal 算法：依次考察权值从小到大的边，若产生环路丢弃，否则添加

**4. 最短路径**

Dijkstra 算法：$L=V-S$，初始为 ${s}$，每个步骤从 $L$ 中选取一个顶点 $v$（$v$ 是 $L$ 中距离 $s$ 最短者）加入 $S$，更新 $s$ 到每个顶点的最短路径长度

Floyd 算法：

Bellman-Ford 算法（可检查负权回路）：

Spfa 算法：

**5. AOV 图和 AOE 网**

AOV 图：顶点表示活动，箭头表示活动间优先关系的有向图

AOE 网：一个带权的有向无环图，顶点表示事件，边表示活动，权值表示活动的时间

> 只有一个入度为0的点（源点），一个出度为0的点（汇点）
>
> 关键路径：从源点到汇点长度最长的路径，长度为完成工程的最短时间
> 关键活动：关键路径上的活动
>
> 算法：
> ![image-20240701025021622](https://gitee.com/mianmann/drawing-bed-warehouse/raw/master/img/image-20240701025021622.png)

#### 排序

**1. 排序算法**

快速排序

堆排序

希尔排序

希尔排序：定义 gap 变量为 N/2，将距离为 gap 的元素分为一组进行插入排序，再将 gap/=2，重复上述操作

插入排序：从第一个元素开始，每个元素一次与前面的元素比较并移动

归并排序：

选择排序：

**2. 排序算法的稳定性**

稳定排序算法：插入、冒泡、归并、基数
不稳定排序算法：简单选择、希尔、快速、堆排
(稳定性：指排序后原来关键值相同的元素相对位置不变
